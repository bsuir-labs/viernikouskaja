#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <conio.h>
#include <algorithm>
#include <sstream>

using namespace std;

/*

	Суть задачи заключается в поиске мостов в графе.
	Подробное описание алгоритма, использованного тут,
	можно прочитать тут: http://e-maxx.ru/algo/bridge_searching
	(Похоже, как раз отсюда все и стащили)

*/

const int MAXN = 20000;				// Максимально возможное количество вершин в графе
									// (из условия)
vector<int> g[MAXN];				// Список смежности графа

int num[MAXN][MAXN];				// Матрица с номерами рёбер для вывода ответа
									// num[a][b] - номер b-того ребра, исходящего из вершины a
int kol[MAXN];						// kol[i] - количество рёбер, исходящих из вершины i
int result[20000];					// Массив с номерами мостов для ответа
bool used[MAXN];					// Массив "помеченных" вершин для алгоритма обхода в глубину,
									// чтобы не ходить по вершинам, по которым уже ходили
int timer, 				// Счётчик "Времени", используется в алгоритме поиска мостов
	arrB[MAXN], 		// Время "входа" в вершину во время обхода в глубину. 
						// В описании алгоритма по ссылке вверху этот массив называется tin
	arrA[MAXN];			// Это массив "fup" из алгоритма по ссылке вверху. Не уверен, что это
						// можно объяснить чётче, чем там
int n;			// Кол-во вершин всего
int pol = 0;	// Тут будет кол-во мостов

// Прототипы функций (описания ниже)
// Чтение графа
void read();
// Обход в глубину вместе с поиском мостов
void dfs(int v, int p);
// Главная функция поиска мостов
void find_bridges();
// Функция, помечающая ребро, как мост
void res(int a, int b, int i);
// Сортировка ответа для вывода
void Sort(int left, int right);

int main()
{
	// инициализируется нулями массив. По идее, не обязательно,
	// т.к. массив объявлен вне функции main, он по стандарту вроде как должен быть обнулён
	for (int u = 0; u < MAXN; u++)
		kol[u] = 0;

	// Читаем граф
	read();

	// Ищем мосты
	find_bridges();

	// Сортируем ответ
	Sort(1, pol);

	// Выводим ответ в файл
	ofstream out("bridges.out");
	out << pol << endl;
	for (int y = 1; y <= pol; y++)
		out << result[y] << " ";
	out << endl << endl;
	out.close();
	return 0;
}

/// Чтение графа
void read()
{
	int Dorogi;	// кол-во дорог
	int t1, t2;	// Номера вершин для каждого ребра (откуда - куда)
	ifstream fin("bridges.in");
	fin >> n;							// читаем кол-во вершин
	fin >> Dorogi;						// читаем кол-во рёбер
	for (int i = 0; i < Dorogi; i++)
	{
		if (fin.eof())
			break;
		fin >> t1;						// читаем ребро
		fin >> t2;
		t1--;							// уменьшаем их на 1, т.к. у нас нумерация
		t2--;							// вершин с 0 будет начинаться
		g[t1].push_back(t2);	// Добавляем в список смежности графа
		g[t2].push_back(t1);
		num[t1][kol[t1]] = i + 1; kol[t1]++;	// И запоминаем номер ребра
		num[t2][kol[t2]] = i + 1; kol[t2]++;
	}
	fin.close();
}

/// Поиск мостов
void find_bridges()
{
	timer = 0;								// Заводим счётчик
	for (int i = 0; i < n; ++i)
		used[i] = false;					// Обнуляем массив "помеченых" вершин
	for (int i = 0; i < n; ++i)				// Перебираем все вершины
		if (!used[i])						// Если мы в вершине ещё не бывали,
			dfs(i,-1); 						// то начинаем обход с этой вершины в поисках мостов
}

/// Обход в глубину
/// параметр v - вершина, куда идём на данном шаге (либо начальная, если только запустили обход)
/// параметр p - родительская вершина, т.е. предыдущая. Если равен -1, то мы только запустились, родителя нету
void dfs(int v, int p = -1)
{
	used[v] = true;								// Помечаем вершину, что побывали в ней
	arrB[v] = arrA[v] = timer++;				// Помечаем в ней время входа
	for (size_t i = 0; i < g[v].size(); ++i)	// Проходимся по списку вершин, связных с текущей
	{
		int to = g[v][i];						// Текущая связная вершина (куда можем пойти из вершины v)

		if (to == p)  continue; 				// Если мы пытаемся пойти назад, откуда пришли, то пропускаем такое ребро

		if (used[to])							// Если мы пытаемся пойти в вершину, где уже были,
			arrA[v] = min(arrA[v], arrB[to]);	// то обновим для текущей вершины массив fup (см. раздел "Алгоритм" по ссылке вверху)
		else									// Иначе
		{
			dfs(to, v);							// Идём глубже по графу
			arrA[v] = min(arrA[v], arrA[to]);	// Обновим массив fup для текущей вершины
			if (arrA[to] > arrB[v])				// И проверим необходимое условие для моста
				res(v, to, i);					// Если это так, то добавляем ребро в ответ
		}
	}
}

/// Добавление ребра в ответ
/// а - начало ребра
/// b - конец ребра
/// i - номер ребра в списке смежности для вершины а
void res(int a, int b, int i)
{
	pol++;						// увеличиваем количество мостов в ответе
	result[pol] = num[a][i];	// и записываем номер ребра в ответ
}


/// Сортировка QSort, сортируется ответ
void Sort(int left, int right)
{
	int i = left, j = right;
	int t, x;
	x = result[(i + j) / 2];
	do {
		while (result[i] < x && i < right) i++;
		while (result[j] > x && j > left) j--;
		if (i <= j) {
			t = result[i];
			result[i] = result[j];
			result[j] = t;
			i++; j--;
		}
	} while (i <= j);
	if (left < j) Sort(left, j);
	if (i < right) Sort(i, right);
}